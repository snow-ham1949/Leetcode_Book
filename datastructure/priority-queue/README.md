---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Priority Queue

允許元素以特定的優先級進行排序和存取。元素會按照優先級出隊，最高優先級的元素最先被移除。

C++ 裡面有 STL 可以用，可以指定要從小排到大，從大排到小，或者自訂 comparator。

（不過要從小排到大的話，我自己比較喜歡用 set，雖然常數比較大，但是就不用寫那麼大一串：）

```cpp
priority_queue<int> pq; // 從大到小
priority_queue<int, vector<int>, greater<int>> pq; // 從小到大
pq.push(10);  // O(lgN)
pq.pop(); // O(lgN)
int tp = pq.top(); // O(1)
```

優先隊列常用於選取任務順序、最短路徑尋找（Dijkstra）。

### Dijkstra

Dijkstra演算法是一個用於在加權圖中找到單一起點到所有其他頂點最短路徑的演算法。這個演算法對於無向圖和有向圖都有效，但前提是圖的所有邊權重必須是非負的。以下是Dijkstra演算法的主要步驟：

1. **初始化**: 在開始時，將所有頂點的最短路徑估計值設定為無限大，只有起點的估計值設為0。這表示起點到自己的最短路徑是0，而到其他所有頂點的最短路徑還未知。
2. **設定未訪問集合**: 創建一個集合來跟踪所有還沒有被訪問的頂點。最初，這個集合包含了圖中的所有頂點。
3. **選擇最短路徑未確定的頂點**: 在未訪問的頂點中選擇一個最短路徑估計值最小的頂點，這個頂點在第一次迭代中會是起點。
4. **更新相鄰頂點的路徑長度**: 考慮當前頂點的所有未訪問的鄰居，並計算從起點到這些鄰居的路徑長度。如果這個計算出的路徑長度比已知的最短路徑更短，則更新這些鄰居的最短路徑估計值。
5. **標記為已訪問**: 將當前頂點標記為已訪問，並從未訪問集合中移除。一旦頂點被標記為已訪問，其最短路徑估計值則被視為是最終的結果。
6. **重複過程**: 重複步驟3至5，直到所有的頂點都被訪問。
7. **結束**: 當所有的頂點都被訪問後，演算法結束。此時，從起點到圖中每個其他頂點的最短路徑就已經被確定了。

Dijkstra演算法的效率可以通過使用優先隊列來提高，這樣可以更快地選擇下一個要處理的頂點。在優先隊列中，頂點根據它們的最短路徑估計值進行排序，這樣就可以快速選取最短路徑估計值最小的頂點。
